pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = credentials('DOCKER_REGISTRY')
        DB_PASSWORD     = credentials('DB_PASSWORD')
        GITHUB_USERNAME = credentials('GITHUB_USERNAME')
        DB_NAME         = 'mydb'
        DB_USER         = 'myuser'
        IMAGE_TAG       = "latest"
    }

    stages {
        stage('Build & Unit Tests') {
            steps {
                sh 'mvn -T 1C clean test'  // T - parallel also
            }
        }

        stage('Build Docker Images') {
            steps {
                sh """
                docker build -t customer-service:${IMAGE_TAG} -f customer-service/Dockerfile .
                docker build -t fraud-service:${IMAGE_TAG} -f fraud-service/Dockerfile .
                docker build -t notification-service:${IMAGE_TAG} -f notification-service/Dockerfile .
                docker build -t exchange-service:${IMAGE_TAG} -f exchange-service/Dockerfile .
                docker build -t exchange-generator-service:${IMAGE_TAG} -f exchange-generator-service/Dockerfile .
                docker build --no-cache -t cash-service:${IMAGE_TAG} -f cash-service/Dockerfile .
                docker build -t transfer-service:${IMAGE_TAG} -f transfer-service/Dockerfile .
                docker build -t front-ui-service:${IMAGE_TAG} -f front-ui-service/Dockerfile .
                docker build -t apigw-service:${IMAGE_TAG} -f apigw-service/Dockerfile .
                """
            }
        }

        stage('Push Docker Images') {
            steps {
                withCredentials([string(credentialsId: 'GHCR_TOKEN', variable: 'GHCR_TOKEN')]) {
                    sh """
                    echo \$GHCR_TOKEN | docker login ghcr.io -u ${GITHUB_USERNAME} --password-stdin
                    """
                }
            }
        }

        stage('Manual Approval for PROD') {
            steps {
                input message: 'Deploy to PROD environment?', ok: 'Yes, deploy'
            }
        }

        stage('Install PostgreSQL to PROD') {
            steps {
                sh """
                helm upgrade --install postgres oci://registry-1.docker.io/bitnamicharts/postgresql \\
                  --namespace prod --create-namespace \\
                  --set auth.database=${DB_NAME} \\
                  --set auth.username=${DB_USER} \\
                  --set auth.password=${DB_PASSWORD} \\
                  --set image.registry=docker.io \\
                  --set image.repository=bitnamilegacy/postgresql \\
                  --set image.tag=latest \\
                  --set image.pullPolicy=IfNotPresent \\
                  --set primary.persistence.enabled=false \\
                  --wait --timeout 5m
                """
            }
        }

        stage('Wait for PostgreSQL in PROD') {
            steps {
                sh """
                kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=postgresql \\
                  -n prod --timeout=300s
                """
            }
        }

        stage('Create DB Secrets for PROD') {
            steps {
                sh """
                kubectl create secret generic customer-service-customer-db \\
                  --from-literal=password=${DB_PASSWORD} \\
                  -n prod --dry-run=client -o yaml | kubectl apply -f -

                kubectl create secret generic fraud-service-fraud-db \\
                  --from-literal=password=${DB_PASSWORD} \\
                  -n prod --dry-run=client -o yaml | kubectl apply -f -

                kubectl create secret generic notification-service-notification-db \\
                  --from-literal=password=${DB_PASSWORD} \\
                  -n prod --dry-run=client -o yaml | kubectl apply -f -

                kubectl create secret generic exchange-service-exchange-db \\
                  --from-literal=password=${DB_PASSWORD} \\
                  -n prod --dry-run=client -o yaml | kubectl apply -f -
                """
            }
        }

        stage('Deploy Zipkin to PROD') {
            steps {
                sh """
                helm repo add bitnami https://charts.bitnami.com/bitnami
                helm upgrade --install zipkin bitnami/zipkin \
                  --namespace prod --create-namespace \
                  -f my-microservices-app/helm/zipkin/values-zipkin.yaml \
                  --wait --timeout 5m
                """
            }
        }

        stage('Deploy Keycloak to PROD') {
            steps {
                sh """
                helm upgrade --install keycloak my-microservices-app/charts/keycloak \\
                  --namespace prod --create-namespace \\
                  --set configMap.enabled=true \\
                  --set image.tag="26.1.3" \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=keycloak.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"
                """
            }
        }

        stage('Deploy Kafka to PROD') {
            steps {
                sh """
                helm upgrade --install kafka oci://registry-1.docker.io/bitnamicharts/kafka \\
                  --namespace prod --create-namespace \\
                  --set image.registry=docker.io \
                  --set image.repository=bitnamilegacy/kafka \\
                  --set image.tag=4.0.0-debian-12-r10 \
                  --set replicaCount=1 \\
                  --set auth.interBrokerProtocol=plaintext \\
                  --set listeners.client.protocol=PLAINTEXT \\
                  --set kraft.enabled=true \\
                  --wait --timeout 5m
                """
            }
        }

        stage('Deploy ELK Stack to LOGGING') {
            steps {
                sh """
                # Create logging namespace
                kubectl create namespace logging || true

                # Create Kafka log topics
                kubectl exec kafka-controller-0 -n prod -- kafka-topics.sh \\
                  --bootstrap-server localhost:9092 --create --if-not-exists \\
                  --topic logs-error --partitions 3 --replication-factor 1 \\
                  --config retention.ms=604800000 || true

                kubectl exec kafka-controller-0 -n prod -- kafka-topics.sh \\
                  --bootstrap-server localhost:9092 --create --if-not-exists \\
                  --topic logs-warn --partitions 3 --replication-factor 1 \\
                  --config retention.ms=604800000 || true

                kubectl exec kafka-controller-0 -n prod -- kafka-topics.sh \\
                  --bootstrap-server localhost:9092 --create --if-not-exists \\
                  --topic logs-info --partitions 3 --replication-factor 1 \\
                  --config retention.ms=604800000 || true

                kubectl exec kafka-controller-0 -n prod -- kafka-topics.sh \\
                  --bootstrap-server localhost:9092 --create --if-not-exists \\
                  --topic logs-debug --partitions 3 --replication-factor 1 \\
                  --config retention.ms=604800000 || true

                # Deploy Elasticsearch
                helm upgrade --install elasticsearch my-microservices-app/charts/elasticsearch \\
                  --namespace logging --create-namespace \\
                  --set enabled=true --set replicas=1 \\
                  --wait --timeout 5m

                # Deploy Logstash
                helm upgrade --install logstash my-microservices-app/charts/logstash \\
                  --namespace logging \\
                  --set enabled=true \\
                  --set kafka.bootstrapServers="kafka.prod.svc.cluster.local:9092" \\
                  --set elasticsearch.hosts="http://elasticsearch-elasticsearch.logging.svc.cluster.local:9200" \\
                  --wait --timeout 5m

                # Deploy Kibana
                helm upgrade --install kibana my-microservices-app/charts/kibana \\
                  --namespace logging \\
                  --set enabled=true \\
                  --set elasticsearch.hosts="http://elasticsearch-elasticsearch.logging.svc.cluster.local:9200" \\
                  --wait --timeout 5m

                echo "ELK Stack deployed successfully!"
                echo "Access Kibana: kubectl port-forward -n logging svc/kibana-kibana 5601:5601"
                echo "Then open http://localhost:5601"
                """
            }
        }

        stage('Wait for Keycloak Ready') {
            steps {
                sh """
                kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=keycloak \
                  -n prod --timeout=300s

                sleep 60
                """
            }
        }

        stage('Move ServiceMonitor Files') {
            steps {
                sh """
                # Create temp directory for ServiceMonitor files
                mkdir -p temp-servicemonitors

                # Move ServiceMonitor files out of templates to prevent namespace error
                mv my-microservices-app/charts/customer-service/templates/servicemonitor.yaml temp-servicemonitors/customer-service-servicemonitor.yaml || true
                mv my-microservices-app/charts/fraud-service/templates/servicemonitor.yaml temp-servicemonitors/fraud-service-servicemonitor.yaml || true
                mv my-microservices-app/charts/notification-service/templates/servicemonitor.yaml temp-servicemonitors/notification-service-servicemonitor.yaml || true
                mv my-microservices-app/charts/apigw-service/templates/servicemonitor.yaml temp-servicemonitors/apigw-service-servicemonitor.yaml || true
                mv my-microservices-app/charts/front-ui-service/templates/servicemonitor.yaml temp-servicemonitors/front-ui-service-servicemonitor.yaml || true
                mv my-microservices-app/charts/transfer-service/templates/servicemonitor.yaml temp-servicemonitors/transfer-service-servicemonitor.yaml || true
                mv my-microservices-app/charts/exchange-generator-service/templates/servicemonitor.yaml temp-servicemonitors/exchange-generator-service-servicemonitor.yaml || true
                mv my-microservices-app/charts/exchange-service/templates/servicemonitor.yaml temp-servicemonitors/exchange-service-servicemonitor.yaml || true
                mv my-microservices-app/charts/cash-service/templates/servicemonitor.yaml temp-servicemonitors/cash-service-servicemonitor.yaml || true
                """
            }
        }

        stage('Helm Deploy to PROD') {
            steps {
                sh """
                helm upgrade --install customer-service my-microservices-app/charts/customer-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=customer-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=customer.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"

                helm upgrade --install fraud-service my-microservices-app/charts/fraud-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=fraud-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=fraud.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"

                helm upgrade --install notification-service my-microservices-app/charts/notification-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=notification-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=notification.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"

                helm upgrade --install exchange-service my-microservices-app/charts/exchange-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=exchange-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=exchange.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"

                helm upgrade --install exchange-generator-service my-microservices-app/charts/exchange-generator-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=exchange-generator-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=exchange-generator.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"

                helm upgrade --install cash-service my-microservices-app/charts/cash-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=cash-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=cash.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"

                helm upgrade --install transfer-service my-microservices-app/charts/transfer-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=transfer-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=transfer.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"

                helm upgrade --install front-ui-service my-microservices-app/charts/front-ui-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=front-ui-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=front-ui.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"

                helm upgrade --install apigw-service my-microservices-app/charts/apigw-service \\
                  --namespace prod --create-namespace \\
                  --set image.repository=apigw-service \\
                  --set image.tag=${IMAGE_TAG} \\
                  --set ingress.enabled=true \\
                  --set ingress.hosts[0].host=apigw.prod.local \\
                  --set ingress.hosts[0].paths[0].path="/" \\
                  --set ingress.hosts[0].paths[0].pathType="ImplementationSpecific"
                """
            }
        }

        stage('Deploy Prometheus Stack to PROD') {
            steps {
                sh """
                helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                helm repo update

                kubectl create namespace monitoring || true

                helm upgrade --install prometheus-stack prometheus-community/kube-prometheus-stack \
                  --namespace monitoring --create-namespace \
                  --set grafana.adminUser=admin \
                  --set grafana.adminPassword=admin \
                  --wait --timeout 10m
                """
            }
        }

        stage('Fix node-exporter for Docker Desktop') {
            steps {
                sh """
                # Patch node-exporter to avoid volume mount issues on Docker Desktop
                kubectl patch daemonset prometheus-stack-prometheus-node-exporter -n monitoring \
                  --type='json' \
                  -p='[{"op": "remove", "path": "/spec/template/spec/containers/0/volumeMounts/2"}, {"op": "remove", "path": "/spec/template/spec/volumes/2"}]' || true

                # Wait for Prometheus stack to be fully ready
                echo "Waiting for Prometheus stack to be ready..."
                sleep 120
                """
            }
        }


        stage('Restore ServiceMonitor Files and Upgrade') {
            steps {
                sh """
                # Restore ServiceMonitor files back to templates
                mv temp-servicemonitors/customer-service-servicemonitor.yaml my-microservices-app/charts/customer-service/templates/servicemonitor.yaml || true
                mv temp-servicemonitors/fraud-service-servicemonitor.yaml my-microservices-app/charts/fraud-service/templates/servicemonitor.yaml || true
                mv temp-servicemonitors/notification-service-servicemonitor.yaml my-microservices-app/charts/notification-service/templates/servicemonitor.yaml || true
                mv temp-servicemonitors/apigw-service-servicemonitor.yaml my-microservices-app/charts/apigw-service/templates/servicemonitor.yaml || true
                mv temp-servicemonitors/front-ui-service-servicemonitor.yaml my-microservices-app/charts/front-ui-service/templates/servicemonitor.yaml || true
                mv temp-servicemonitors/transfer-service-servicemonitor.yaml my-microservices-app/charts/transfer-service/templates/servicemonitor.yaml || true
                mv temp-servicemonitors/exchange-generator-service-servicemonitor.yaml my-microservices-app/charts/exchange-generator-service/templates/servicemonitor.yaml || true
                mv temp-servicemonitors/exchange-service-servicemonitor.yaml my-microservices-app/charts/exchange-service/templates/servicemonitor.yaml || true
                mv temp-servicemonitors/cash-service-servicemonitor.yaml my-microservices-app/charts/cash-service/templates/servicemonitor.yaml || true

                # Remove temp directory
                rmdir temp-servicemonitors || true

                # Upgrade all charts to apply ServiceMonitor
                helm upgrade customer-service my-microservices-app/charts/customer-service -n prod
                helm upgrade fraud-service my-microservices-app/charts/fraud-service -n prod
                helm upgrade notification-service my-microservices-app/charts/notification-service -n prod
                helm upgrade apigw-service my-microservices-app/charts/apigw-service -n prod
                helm upgrade front-ui-service my-microservices-app/charts/front-ui-service -n prod
                helm upgrade transfer-service my-microservices-app/charts/transfer-service -n prod
                helm upgrade exchange-generator-service my-microservices-app/charts/exchange-generator-service -n prod
                helm upgrade exchange-service my-microservices-app/charts/exchange-service -n prod
                helm upgrade cash-service my-microservices-app/charts/cash-service -n prod
                """
            }
        }

        stage('Apply PrometheusRule') {
            steps {
                sh """
                # Apply custom alerting rules
                kubectl apply -f my-microservices-app/helm/prometheus/prometheusrule-simple.yaml

                echo "Deployment complete! ServiceMonitors and PrometheusRules applied. Now execute the following commands:"
                echo "kubectl port-forward -n monitoring svc/prometheus-stack-kube-prom-prometheus 9090:9090"
                echo "kubectl port-forward -n monitoring svc/prometheus-stack-grafana 3000:80"
                """
            }
        }
    }
}